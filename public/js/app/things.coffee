app = angular.module("QueGui")

# controller for things list
app.controller "ThingsController", ($scope, $http, $rootScope, thingService, blockService, $interval, $document, tokenService) ->
  root = this
  @things = []
  @selectedThing = null
  @editMode = false
  
  # thing authentication key
  @authKey = null
  
  # new thing to be added
  @newThing = null
  @newControl = {}
  
  # custom thing
  @customThing = {}
  @customActions = [
    name: "123"
    trigger: {}
    detrigger: {}
  ]
  
  # spark token is validated
  @sparktokenvalidated = false
  
  # check if spark token is real
  @validateSparkToken = ->
    @sparktokenvalidated = @newThing.id.length is 24
    return

  
  # go to next page of add dialog
  @addNextPage = ->
    @newThing.dialogPage++
    
    # change page count
    switch root.newThing.type
      when "spark"
        root.newThing.pageCt = 2
      else
        root.newThing.pageCt = 1

  
  # previous page
  @addPrevPage = ->
    @newThing.dialogPage--
    return

  @addFinish = ->
    
    # initialize thing
    thing =
      actions: []
      data: {}
      name: root.newThing.name
      desc: root.newThing.desc
      tags: (root.newThing.tags or "").split(" ")

    
    # initialize a potential block
    block = null
    
    # is this a custom thing?
    switch root.newThing.type
      when "manual"
        thing = _.extend(thing, JSON.parse(root.customThing))
      when "actions"
        thing.actions = root.customActions
      
      # preprocessing for spark
      when "spark"
        root.newThing.actions = []
        
        # prepend some code (the header)
        block =
          name: thing.name + " Controller"
          desc: thing.desc
          code: [
            "// Generated by Que on " + (new Date()).toString()
            "que.getThingById(%THINGID%, function(thing, n) {"
          ]

        
        # add each pin to the list
        _.each root.newThing.pins, (pinv, pin) ->
          
          # for each output pin
          unless root.newThing.pinMode[pin]
            
            # add controls for each pin automatically,
            # to make the user's job easier
            thing.data[pinv] =
              value: false
              name: pinv

            
            # what type is the pin?
            pintype = pin[0] is "D" and "digital" or "analog"
            
            # add actions for each pin
            thing.actions.push
              name: pinv
              trigger:
                method: "POST"
                url: "https://api.spark.io/v1/devices/" + root.newThing.id + "/" + pintype + "write"
                form:
                  args: pin + "," + (pintype is "digital" and "HIGH" or "255")
                  access_token: tokenService.tokens.sparktoken

              detrigger:
                method: "POST"
                url: "https://api.spark.io/v1/devices/" + root.newThing.id + "/" + pintype + "write"
                form:
                  args: pin + "," + (pintype is "digital" and "LOW" or "0")
                  access_token: tokenService.tokens.sparktoken

            
            # add the required code to the block
            block.code.push "  if (thing.data." + pinv + ".value == true) {"
            block.code.push "    que.getActions(thing)." + pinv + ".trigger(function(status) {"
            block.code.push "      // do something here when the pin turns on"
            block.code.push "    });"
            block.code.push "  } else {"
            block.code.push "    que.getActions(thing)." + pinv + ".detrigger(function(status) {"
            block.code.push "      // do something here when the pin turns off"
            block.code.push "    });"
            block.code.push "  }"
          else
            
            # input pin
            
            # add actions for each pin
            thing.actions.push
              name: pinv
              trigger:
                method: "POST"
                url: "https://api.spark.io/v1/devices/" + root.newThing.id + "/digitalread"
                form:
                  args: pin
                  access_token: tokenService.tokens.sparktoken

              detrigger: {}

            
            # add the required code to the block
            block.code.push "  que.getActions(thing)." + pinv + ".trigger(function(status, resp, body) {"
            block.code.push "    if (body.return_value) {"
            block.code.push "      // do something here when the pin is on"
            block.code.push "      que.log('" + pinv + " is on.');"
            block.code.push "    } else {"
            block.code.push "      // do something here when the pin is off"
            block.code.push "      que.log('" + pinv + " is off.');"
            block.code.push "    };"
            block.code.push "  });"
          return

        
        # the last curly brace
        block.code.push "});"
    
    # add the thing to the database serverside
    $http(
      method: "POST"
      url: "/things/add"
      data: angular.toJson(thing)
    ).success (data) ->
      
      # clear thing cache
      thingService.cache = {}
      if block
        
        # replace id
        block.code[1] = block.code[1].replace("%THINGID%", data.id)
        
        # and, if the block was defined, add it too
        $http(
          method: "POST"
          url: "/blocks/add"
          data: JSON.stringify(block)
        ).success ->
          $rootScope.$broadcast "updateBlocks", null
          root.refresh()
          return

      else
        root.refresh()
      return

    return

  
  # initialize the newThing object on cancel (or on start)
  # and the customThing JSON string if the user is adding a custom thing
  @addCancel = ->
    root.newThing =
      dialogPage: 0
      pageCt: 1
      idClaimed: false
      type: ""
      pins: {}
      pinMode: {}
      actions: {}
      finished: false

    root.customThing = JSON.stringify(
      actions: []
      data: []
    , null, 2)
    root.customActions = []
    return

  
  # run this now
  @addCancel()
  
  # also, bind it to modal close
  $("#addThingModal").on "hidden.bs.modal", ->
    root.addCancel()
    $scope.$apply()
    return

  
  # get all data from server
  thingService.getAllThings (data) ->
    root.things = data
    return

  
  # given a data type, get the textbox type it would go into
  @getTypeFor = (value) ->
    if value.type
      value.type
    else
      switch typeof value.value
        when "number"
          return "number"
        when "boolean"
          return "checkbox"
        when "canvas", "video"
          return "canvas"
        else
          return "text"

  
  # is this control represented as a button?
  @isButton = (v) ->
    v.type is "button"

  
  # update backend on keypress
  @updateThingData = (id, key, value, callback) ->
    data = {}
    data[key] = value
    thingService.updateThingData id, data, callback or ->

    return

  
  # convert from CamelCase or underscore-format to normal, smaced words
  @convertIntoSpaces = (string) ->
    
    # insert a space between lower & upper
    
    # space before last upper in a sequence followed by lower
    
    # uppercase the first character
    # insert a space between lower & upper
    
    # space before last upper in a sequence followed by lower
    
    # uppercase the first character
    string = string.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/\b([A-Z]+)([A-Z])([a-z])/, "$1 $2$3").replace(/^./, (str) ->
      str.toUpperCase()
    ).replace(/([a-z])([A-Z])/g, "$1 $2").replace(/\b([A-Z]+)([A-Z])([a-z])/, "$1 $2$3").replace(/^./, (str) ->
      str.toUpperCase()
    )
    string.replace("-", " ").replace "_", " "

  @removeThing = (id, index) ->
    root.things.splice index, 1
    thingService.removeThing id, ->

    return

  
  # add a new control to the list of them
  @addControl = (id) ->
    thingService.getAllThings (things) ->
      
      # get by id
      ts = _.filter(things, (t) ->
        t.id is id
      )
      
      # calculate value
      switch root.newControl.type
        when "bool", "button"
          root.newControl.value = false
          delete root.newControl.type
        when "number"
          root.newControl.value = 0
          delete root.newControl.type
        when "canvas"
        else
          root.newControl.value = ""
          delete root.newControl.type
      
      # add each control to the thing
      _.each ts, (thing) ->
        
        # thing.data[root.newControl.name] = root.newControl;
        root.updateThingData id, root.newControl.name, root.newControl, ->

        return

      return

    return

  @deleteControl = (id, cname, callback) ->
    console.log 1
    thingService.getAllThings (things) ->
      
      # get all matching things
      things.filter((i) ->
        i.id is id
      ).forEach (thing) ->
        console.log 2
        thing.data[cname] = null
        thingService.updateThingData id, thing.data, ->
          callback and callback()
          return

        return

      return

    return

  @refresh = ->
    thingService.getAllThings (data) ->
      if $(":focus").length is 0 or _.contains([
        "checkbox"
        "button"
      ], $(":focus").attr("type"))
        
        # if a new item was added, hide the modal
        $("#addThingModal").modal "hide"  if root.things.length isnt data.length
        
        # update the data
        root.things = data
      return

    return

  socket.on "backend-data-change", (payload) ->
    if payload and payload.type is "thing"
      root.refresh()
      $scope.$apply()
    return

  socket.on "canvas-update", (data) ->
    canvas = $(".canvas-" + data.id + "-" + data.key)[0]
    cxt = canvas.getContext("2d")
    
    # colors
    cxt.fillStyle = data.fillColor  if data.fillColor
    cxt.strokeStyle = data.strokeColor  if data.strokeColor
    
    # what to do?
    switch data.action
      when "clear"
        cxt.clearRect data.x or 0, data.y or 0, data.w or canvas.width, data.h or canvas.height
      when "line"
        
        #
        #        {
        #          action: "line",
        #          nodes: [
        #            [0, 0],
        #            [10, 10]
        #          ],
        #          fillColor: "red",
        #          strokeColor: "red",
        #          finished: "stroke"
        #        }
        #        
        
        # start drawing line
        cxt.beginPath()
        cxt.moveTo data.nodes[0][0], data.nodes[0][1]
        
        # each node
        _.each _.rest(data.nodes), (n) ->
          cxt.lineTo n[0], n[1]
          return

        
        # finish
        (data.finished is "fill") and cxt.fill()
        (data.finished is "stroke") and cxt.stroke()
      when "rect"
        
        # draw rectangle
        cxt.fillRect data.x or 0, data.y or 0, data.w or canvas.width, data.h or canvas.height
      when "text"
        
        # draw text
        cxt.fillText data.text, data.x or 0, data.y or 0
      when "image"
        
        # add image to canvas
        img = new Image()
        img.src = data.src
        img.onload = ->
          cxt.drawImage img, data.x or 0, data.y or 0
          return

  return

